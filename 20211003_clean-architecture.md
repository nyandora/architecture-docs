クリーンアーキテクチャを改めて学習・整理

アーキテクチャ設計の目的は、低いコストで変更できるようにすること。

それを実現できる構造が必要。構造は大事。

アーキテクチャには堅牢性だけでなく、このような変更容易性も必要。

◆第Ⅱ部　構成要素から始めよ：プログラミングパラダイム

依存性逆転により、コンポーネントそれぞれを独立してデプロイ・開発可能と書かれているが、実際には無理でしょ。サーバー単位で分けないとそれは無理。
プラグイン可能とあるが、実際には切り替えることなんてほとんどない。

ただ、依存関係の方向性を好きなように制御して、あるクラスを変更しても別のクラスを変更しなくてもよい、という状態に持っていくことができる。ただ、これがとても重要と言われているが、個人的には納得できていない。詳細については「オープン・クローズドの原則」のセクションで述べている。

可変コンポーネントは並行処理で問題になったりするので避けるべき。

◆第Ⅲ部　設計の原則

クラスレベル向けの原則：SOLID

目的は、クラスを以下の状態にすること。

* 変更に強くする
* 理解しやすくする
* 再利用できるようにする

単一責任の原則

クラスの利用者ごとにクラスを分けるべき。利用者ごとにそのクラスをどう使いたいかが異なるため。ある利用者向けの変更をすることで、別の利用者に影響を与えないようにしよう、ということ。別々の利用者向けの修正が同時にされることで、マージの手間も生まれてしまう。

オープン・クローズドの原則

あるクラスを変更する場合、既存の他クラスの修正は最小限に留めるべき。（＝ 拡張に対しては開いていて、修正に対しては閉じているべき。）

これを実現するために、ビジネス上コアな処理を常に「依存される」側となるよう、依存関係を調整する。

だが、実際には画面とコアなビジネスロジックはセットで変更になることが多いはずで、このように調整しても実際にはあまりメリットはない。つまり、コアなビジネスロジックだけを修正すればビューは変更不要、ということはあまり無い。

だから、この原則は実益という面では重要性は低い。

リスコフの置換原則

この本質は、呼び出し先を他のパーツに変更しても、呼び出し元がコード上の影響を受けないようにすべき、ということ。呼び出し先のクラスがAの場合、呼び出し元が特別な処理（if文など）をするようだと、特別扱いが発生して変更が大変になってしまう。

インターフェイス分離の原則

あるクラスが、本来関係のないものに依存していると、その関係ないのものが変更された時にクラスの再コンパイル・再デプロイが必要となる。それを避けるためにインタフェースを分離すべき、というもの。

だが、通常どこかを変更したら全量のコンパイル・デプロイが必要になるから、この原則も重要性は低い、というか考慮不要ではないかと思う。

依存関係逆転の原則

クラスはできるだけ抽象（インターフェイス）に依存すべき。なぜならインターフェースは変更しないよう設計されるのが普通であり、その変更されないものに対して依存しておけば、クラスも変更されづらくなるから。

つまり、この原則はインターフェイスが変更されづらいものとなるよう、注意深く設計されていることが大前提となる。インターフェイスに依存させるようにしたとしても、そのインターフェイスそのものがコロコロ変更されるようであれば、何の意味もない。

◆第Ⅳ部　コンポーネントの原則

どのクラスをどのコンポーネントに含めるか、ということについての原則。

再利用・リリース等価の原則　The Reuse/Release Equivalence Principle (REP)

特定のクラスやクラス群を再利用するのではなく、リリースされた「コンポーネント全体」を最小の単位として再利用しましょう、ということ。これを推し進めると、コンポーネントは大きくなる。

コンポーネントというのはある程度のまとまり（クラスの集まり）であり、リリース周りの管理がしっかりされているべきだ、という意味。

リリース周りの管理とは

* リリースに対してバージョン番号を振ること。
* リリースによってどんな影響があるかを、呼び出し元に公開すること。
* Maven Centralなどにコンポーネントを登録すること。

これを疎かにすると、利用する側はとっても困る。最悪、そのコンポーネントを再利用できなくなる。

なぜなら

* コンポーネントをvupしようとしても、自分たちにどんな影響があるのか分からない。
* 本来１つのコンポーネントにまとめるべきクラスが、複数のコンポーネント（JAR）に分かれている場合、それら両方を依存関係に含める必要あり。

この原則を推し進めると、リリース運用がすごく大変になる。いちいちバージョン番号を振ったり、変更による影響を公開する必要があるため。

閉鎖性共通の原則　The Common Closure Principle (CCP)

何らかの理由でコンポーネントを修正すべきとなったときに、修正すべきコンポーネントは１つだけの方が楽。なので、修正すべき理由が同じクラス群は、１つのコンポーネントにまとめるべき。修正範囲はコンポーネント内に限定される（閉じる）、という意味で「閉鎖性」という表現が使われている。

この原則を推し進めると、コンポーネントは大きくなる。

再利用共通の原則（わたくし独自の命名）　The Common Reuse Principle (CRP)　

一緒に利用されることが多いクラス群、密結合なクラス群は１つのコンポーネントにまとめるべき。

逆に、密結合していないクラス群を１つのコンポーネントに含めるべきではないと言われている。これに反すると、利用する側にとってはどうでも良いクラスが変更された場合でも、利用する側の再コンパイル・再デプロイが必要になる、という理由。でも、別にどうでも良い変更なら利用する側では新しいコンポーネントを取り込まなければ良いだけなんだから、そこまで大きな話ではないと思われる。

ということで、この原則に従って、コンポーネントが大きくなっても、あんまり問題にならないと思ってる。

※「全再利用の原則」と訳されているが、これは不適切な訳。「The Common Reuse Principle」のどこにも「All」とは書いてない。

書籍では、各原則にはトレードオフの関係があると言っているが、上記のとおり全てコンポーネントが大きくなる方向で特段問題ないので、私としてはトレードオフなど無いと考えている。

上記原則を気にしながら、凝集性の高いコンポーネントにしていけば良いはず。

（次は14章から）







