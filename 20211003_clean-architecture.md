クリーンアーキテクチャを現場に適用するにあたり、理解しておくべき本質

# はじめに

本記事は、書籍「クリーンアーキテクチャ」の内容を、業務経験を踏まえて私なりに噛み砕いて整理したものです。

クリーンアーキテクチャを理解するには、上っ面ではなく本質を理解する必要があります。

しかし、書籍を一人で読むだけでは、そういった本質の理解をしづらく、頭を抱えた方も多いのではないでしょうか？

この記事が、「クリーンアーキテクチャの本質を正しく理解する」ことの手助けになれば嬉しいです。

ところどころ、私見が入っていますのでその点はご容赦ください。また適宜アップデートしていこうと思います。

## クリーンアーキテクチャの要旨

システムを構築、修正するにあたり、それにかかるコストを低く抑えることが重要です。

コストを抑えるには、アーキテクチャという「構造」が適切であるべきです。

## 用語の説明

* コンポーネント：ソースコードのある程度のまとまり（典型的にはクラスの集まり）
* アーキテクチャ：コンポーネントにより構成されるシステムの構造のこと
  * この定義においては、いわゆるマイクロサービスアーキテクチャはアーキテクチャではありません（後述）。

# 設計の原則　〜アーキテクチャ設計に必要な前提知識〜

アーキテクチャ設計の話に入る前に、その前提となる各種原則を理解しておく必要があります。

## SOLID原則

### 単一責任の原則（Single-responsiblity Principle）

クラスの利用者（文脈）ごとにクラスを分けるべきです。利用者ごとに「そのクラスをどう使いたいか」が異なるためです。

クラスが複数の利用者から利用される場合、ある利用者だけを想定した修正が、別の利用者にも影響を与えてしまう恐れがあります。

また、別々の開発者が異なる理由でそのクラスを同時に修正することが起きやすく、コンフリクト解消の手間も生まれてしまいます。

### オープン・クローズドの原則（Open-closed Principle）

ビジネス上コアな処理を修正せずに、それ以外の瑣末なものを拡張できるようにすべきです。（＝ 拡張に対しては開いていて、修正に対しては閉じているべき。）

これを実現するために、ビジネス上コアでない瑣末な処理を、常に「依存する」側に配置すべきです。時には依存関係を逆転させる必要があります。

「今後、どんな変更があり得るのだろうか？」を考え、その変更の時に、よりコアなところを修正しなくても済むように、依存関係を調整するのがアーキテクトの腕の見せどころでしょう。

なお、現場では、コアなビジネスロジックが変わり、結果としてそれに依存する画面にも変更が入ることもそれなりにあります。その場合、この原則では対応できません。この原則は、そういった変更を意図したものではないのです。

コアなビジネスロジックは変わらないけど、それ以外の瑣末なところだけ変えたい、という時に簡単に変更できるようにしましょう、というのがこの原則の本質です。

### リスコフの置換原則（Liskov Substitution Principle）

具象クラスは、抽象クラス/インターフェースが表す概念の一種になっているべきです。

この本質は、呼び出し先を他のパーツに変更しても、呼び出し元がコード上の影響を受けないようにすべき、ということです。呼び出し先のクラスがAの場合、呼び出し元が特別な処理（if文など）をするようだと、特別扱いが発生して変更が大変になってしまいます。

### インターフェイス分離の原則（Interface Segregation Principle）

あるクラスが、本来関係のないものに依存していると、その関係ないのものが変更された時にクラスの再コンパイル・再デプロイが必要となります。それを避けるためにインタフェースを分離すべき、というものです。

ですが、通常どこかを変更したら全量のコンパイル・デプロイが必要になるから、この原則も重要性は低い、というか考慮不要だと思います。

### 依存関係逆転の原則（Dependency Inversion Principle）

具象クラスに依存するのではなく、逆に抽象に依存すべきです。そうなるように依存関係を自由自在に制御しましょう。

目的は、依存先が変更されても、依存元が影響を受けないようにすることです。

この原則はインターフェイスが変更されづらいものとなるよう、注意深く設計されていることが大前提となります。インターフェイスに依存させるようにしたとしても、そのインターフェイスそのものがコロコロ変更されるようであれば、意味はありません。

## コンポーネントの「凝集性」に関する原則
どのクラスをどのコンポーネントに含めるか、ということについての原則です。

書籍では、各原則にはトレードオフの関係があると言っているが、後述のとおり全てコンポーネントが大きくなる方向で特段問題ありません。ですので、私としてはトレードオフは無い（考慮不要）と考えています。

各原則を気にしながら、凝集性の高いコンポーネントにしていけば良いでしょう。

### 再利用・リリース等価の原則（The Reuse/Release Equivalence Principle）

特定のクラスやクラス群を再利用するのではなく、リリースされた「コンポーネント全体」を最小の単位として再利用しましょう。これを推し進めると、コンポーネントは大きくなります。

コンポーネントというのはある程度のまとまり（クラスの集まり）であり、リリース周りの管理がしっかりされているべきだ、という意味です。

リリース周りの管理とは以下のようなものです。

* リリースに対してバージョン番号を振ること。
* リリースによってどんな影響があるかを、呼び出し元に公開すること。
* Maven Centralなどにコンポーネントを登録すること。

これを疎かにすると、利用する側はとっても困ります。最悪、そのコンポーネントを再利用できません。

なぜなら

* コンポーネントをvupしようとしても、自分たちにどんな影響があるのか分からないからです。
* 本来１つのコンポーネントにまとめるべきクラスが、複数のコンポーネント（JAR）に分かれている場合、それら両方を依存関係に含める必要があるからです。

この原則を推し進めると、リリース運用がすごく大変になります。いちいちバージョン番号を振ったり、変更による影響を公開する必要があるためです。

ですので、開発の初期ではこの原則はあまり重要視されません。

### 閉鎖性共通の原則（The Common Closure Principle）

何らかの理由でコンポーネントを修正すべきとなったときに、修正すべきコンポーネントは１つだけの方が楽です。なので、修正すべき理由が同じクラス群は、１つのコンポーネントにまとめるべきです。修正範囲はコンポーネント内に限定される（閉じる）、という意味で「閉鎖性」という表現が使われています。

この原則を推し進めると、コンポーネントは大きくなります。

### 再利用性 共通の原則（The Common Reuse Principle）

※「全再利用の原則」と訳されていますが、これは不適切な訳です。「The Common Reuse Principle」のどこにも「All」とは書かれていないからです。

一緒に利用されることが多いクラス群、密結合なクラス群は１つのコンポーネントにまとめるべきです。

逆に、密結合していないクラス群を１つのコンポーネントに含めるべきではな無いと言われています。これに反すると、利用する側にとってはどうでも良いクラスが変更された場合でも、利用する側の再コンパイル・再デプロイが必要になる、という理由です。

しかし、別にどうでも良い変更なら利用する側では新しいコンポーネントを取り込まなければ良いだけなので、そこまで重要な話ではないです。

ということで、この原則に従ってコンポーネントが大きくなっても、あんまり問題にはなりません。

## コンポーネントの「結合」に関する原則

コンポーネント間の関係性について、いくつか原則があります。

### 非循環依存関係の原則（Acyclic Dependencies Principle）

循環依存がダメなのは解説するまでもありませんよね。（おわり）

### 安定依存の原則（Stable Dependencies Principle）

依存する側からされる側へ、どんどん依存関係のグラフを辿っていくと、奥にあるコンポーネントほど変更しづらくなっていきます。なぜなら、修正時の影響範囲が大きくなってしまうからです。

このような「依存されまくってるために変更しづらい度合い」のことを安定度と呼びます。

安定依存の原則が言わんとするところは、変更する見込みのあるコンポーネントは、安定度の高いものに依存するのはOKだが、その逆（安定度の高いものから依存される）はNG、ということです。

どうしても、それを回避できない場合は、対象のコンポーネントと安定度の高いものとの間にインターフェース等の抽象層を挟んで依存関係を逆転させ、誰にも依存されない状態を作り出すべきです。そうすることで、誰の顔色も伺わずに修正できるようになります。

### 安定度・抽象度等価の原則（Stable Abstractions Principle）

安定度の高さと抽象度の高さは一致させておこう、という原則です。具体的には以下のとおりです。

* 安定度の高いコンポーネント（他から依存されまくるもの）ほど、変更しやすさを確保するために抽象度を高くしましょう（インターフェイス等をたくさん使おう）。安定度が高いということは、色々なところから依存されまくっており、変更するハードルがすごく高いということです。そうであっても変更しやすさを確保するために、抽象層を挟むべきです。
* 逆に、安定度の低いコンポーネント（他に依存しまくるもの）ほど、抽象化するのは無駄なだけなので抽象度は低くすべきです。

なお、安定度が高い＝良い、と言う話ではありません。安定度に応じて、適切な抽象度を選ぶべきということです。


# アーキテクチャ設計

## アーキテクチャ設計とは何か（what）
アーキテクチャ設計とは、変更の理由・頻度が異なるものを相互に分離し、それらの間の構造を定義することです。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/architecure-separation-orientation.drawio.svg)

先に挙げた各種の原則にのっとって、設計をしていくことになります。

## アーキテクチャ設計の目的とは（why）

アーキテクチャ設計の目的は以下です。

* 状況の変化に応じて、実装の詳細を変更・拡張しやすくする。
  * 例えば、ブラウザだけでなくモバイルアプリにも対応できるようにする。
* 開発チームが、余計なコストを負わずに開発できるようにする。
  * 例えば、少人数のチーム１つだけなら、無闇にコンポーネントを分割して境界を設けない方がやりやすいかもしれない。一方、複数チームなら、チーム同士が干渉せずに（余計なコストが発生せずに）開発できるようにするため、境界を設けるのが適切。
* デプロイの手間を許容範囲に抑える。
  * 例えば、無闇にマイクロサービスでコンポーネントを分けると、関係するマイクロサービス全てをデプロイする必要に迫られ、デプロイのコストが高くなる。
* 保守をしやすくする。どこを直すべきかが分かりやすい状態にする。

その先にある究極的な目的は、本記事の冒頭で記載した通り「コストを下げること」です。

## アーキテクチャ設計の再重要ポイント

コアなビジネスルールを持つコンポーネントに対して、そうでないコンポーネントが依存するようにすべきです。後者はプラグインであり、前者に影響を与えることなく切り替えられるようにすべきです。

例えばGUIは後者であり、プラグインであり、システムの本質ではありません。コアなビジネスルールとは違い、状況によって移り変わるものなので、切り替えできるようにすべきです。「IOは無関係」なのです。

前者は上位のコンポーネントであり、後者は下位のコンポーネントです。入出力が最も下位であり、入出力から離れているほど上位となります。

最上位なのはビジネスルールであり、エンティティおよびユースケースです。

![](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/business-rule.svg)

ビジネスルールは、実装の詳細・方式には依存しません。例えば、WebなどのIO形態やFWには依存しません。

システムはビジネスルールを中心とし、実装の詳細を中心とすべきではありません。

以上を表したのが、有名な同心円の図です。以下の図は、これを私なりに噛み砕いて表現したものです。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/clean-architecure-circles.drawio.svg)

この図の本質は、多くのシステムはこのように水平方向での分割を適用できる、ということです。これが全てに当てはまるわけではありませんし、この分割だけで十分というわけでもありません。

「この図を出発点に考えるのが良いよ」くらいでとらえる必要があります。この図のとおりに作れば完璧だ、ということではないのです。

特に、「エンティティ」「ユースケース」の内部も、上流・下位のコンポーネント分割をすべきでしょう。この図では、Web/FW/外部IFなどの「代表的な実装の詳細」だけが下位に位置づけられていますが、多くのケースで当てはまるという話なだけであって、肝心なのはビジネスルールをどう料理するか、です。

また、書籍では例の同心円の図の右下に、以下のような図が登場します。以下のように、この図の本質は、「制御の流れがどうであっても、依存の方向を適切に制御すべき」ということです。依存の方向が、同心円の図の矢印と同じ方向になるよう、調整すべきなのです。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/clean-architecture-flow-and-dependency.drawio.svg)

なお、Spring MVCなどの一般的なMVCフレームワークでは、制御の流れは上の図とは異なり、以下のようになるでしょう。

```
◆Spring MVCでの制御の流れ
コントローラー
→ ビジネスロジック
→ コントローラー（ビジネスロジックから制御が戻ってくる）
→ View（Thymeleafなど）
→ Presenter
```

それでも、「依存の方向を適切に」という本質は変わりません。

## アーキテクチャ設計におけるトピック

### 切り離し方式のバリエーション

分離したコンポーネントを物理的にどう分割するか（切り離し方式）については、選択・変更できるようにしておきましょう。切り離し方式（マイクロサービス化するなど）そのものは、アーキテクチャではありません。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/how-to-separate-components.drawio.svg)

最適な切り離し方式をギリギリまで吟味したり、運用しながら変更できることに価値があります。

なお、書籍では「独立してコンパイル・デプロイ可能」といった表現がよく出てきます。

これは以下の切り離し方式でのみ有効だと思います。

* ローカルプロセスレベルの分離
* サービスレベルの分離


つまり、「独立してコンパイル・デプロイ可能か」というのはコンポーネントが適切に分割されているだけではなく、切り離し方式にも左右されるということです。

### テストしづらいコンポーネントの扱い方

テストしづらいものからロジックを追い出し、テストしやすいクラスにロジックを移しましょう。

前者はHumble（控えめ = ロジックを極力持たせない）なもの、と呼びます。以下の図のとおりです。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/humble-object.drawio.svg)

ということは、Humbleなものに自動テストを設けるのは、ナンセンスということですね。例えば、DBアクセス用のImplの自動テストを作るのは、ただただコストがかかるだけだよ、ということです。

### コンポーネントの境界をどれだけしっかり作るか

コンポーネント間の境界をどれだけしっかり作るか、には程度（選択肢）があります。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/component-separation-levels.drawio.svg)

状況に応じて、適切なものを選ぶことが大事です。
例えば、本当にその境界が必要なのかが判断できない時は、ゆるいやつを選んでおくのが良いでしょう。

### 未来を予想して、境界を予め設ける

境界を設けるのはけっこう難しいです。

境界をつくるということは少なからず手間が発生します。
なので、はじめから無闇に境界を設けるべきではありません。

一方で、全く境界がないところに、一から境界を設け直すのは不可能に近いでしょう。
既存のものに影響を与えずに境界を設けるのは「大手術」であり、リスクとコストが大き過ぎます。

ですので、未来を予想して、境界を絶妙に設けておく必要があります。
ここがアーキテクトの腕の見せどころです。

なお、書籍にあるマイクロサービスの例は、「境界を設けるべきか悩ましいケースがあり、未来予想によっては境界が必要と判断するケースがあるよ」ということを示しているだけ。必ずこうしましょう、という話ではありません。

### 実装の詳細に過ぎないものたち

#### サービス

サービスは単なる高価な関数呼び出しに過ぎません。

言い換えると、実装の詳細、つまり実行の物理的な仕組みや通信の方式に過ぎず、アーキテクチャを決定づけるものではありません。

アーキテクチャの境界は、サービスの分割とは別次元で（直行して）存在し得えます。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/architecutre-boundary-cross-over-service.drawio.svg)

#### Web、DB、FW

これらも実装の詳細に過ぎません。状況によって変更すべきものです。

しかし、実際のシステム開発の現場では、これらの実装の詳細が「神」のように扱われています。

この牙城を崩すのはかなり難しいとは思いますが、アーキテクトとしてこの本質を理解しておくことは必要でしょう。

### 抽象に対してテストすべき

テストも抽象に依存させるのが正しいです。つまり、実装の詳細という変化しやすいものに依存してはいけません。

プロダクションコードの個々のクラスやメソッドに対して、細かく自動テストを設けていたら、変更時にとんでもない負担になるだけです。

ユースケースやエンティティといった、上位レベルの抽象的なものに対してテストをすべきです。その際、DBアクセスやAPIコールなどの動作を再現しづらいものは、モック化しておけば良いです。

### 境界は強制されるべき

プログラマに境界のルールを強制させないと、せっかくのアーキテクチャ設計が台無しになってしまいます。

Java 9で導入されたモジュールなどを利用して、コンパイラにチェックさせるようにするのが好ましいです。

### Mainコンポーネントは実装の詳細で切り替え可能

円の最も外側に、アプリケーションのエントリーポイントが存在します。

これはMainコンポーネントと呼ばれます。
Mainコンポーネントは *究極的な実装の詳細であり、プラグイン（切り替えられるもの）* です。

このコンポーネントは、具体的には以下を行います。

* 依存関係の注入
* 設定値の読み込み
* 上位レベルのコンポーネントに制御を移す

Spring Bootでいえば、`@SpringBootApplication`をつけたクラスが該当します。

### プログラミングパラダイムとアーキテクチャ

アーキテクチャ設計では、以下が求められます。

* コンポーネントをテスト可能（反証可能）な単位にすること。（構造化プログラミングに通ずる）
  * そうならないように作る方が逆に難しいくらいだけど・・。
* ポリモーフィズムを使って、コンポーネント間の依存関係の方向を、自在に制御できること。（オブジェクト指向プログラミングに通ずる）
* 状態を持つコンポーネントをできるだけ作らないこと。（関数型プログラミングに通ずる）
  * 並行性の問題を避けるため。

# おわりに

クリーンアーキテクチャのいう「アーキテクチャ」とは、一般的な意味でのアーキテクチャとは異なる概念のように思います。

一般的な意味といっても千差万別ですが、業務アプリ以外の全てとか、アプリ基盤とか、非機能とかそういったイメージがあるのではないでしょうか。

そういったものは堅牢さを確保するためには必要ですが、私の経験では「コストを下げる」という観点はあまり考慮されてきませんでした。

クリーンアーキテクチャはその観点で必要な考え方だと思います。

この記事をご覧になって理解されたかもしれませんが、クリーンアーキテクチャでは特定の実装の詳細について、とやかく言っていません。ですので、「クリーンアーキテクチャはこう実装するのが正しい」という主張を、真に受けるべきではありません。実装の詳細は、状況によって違うのです。それは、現場で一生懸命考えるしかありません。

ということで、次なる問題は、この記事で学んだクリーンアーキテクチャの本質を使って、現場のシステムをどう構築していくか、という話です。

あんまり具体的な話になってもしょうがないのですが、別の記事でそういった話題を取り上げていきたいと思っています。