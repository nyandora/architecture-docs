クリーンアーキテクチャ

# ◆第Ⅰ部　イントロダクション

アーキテクチャ設計の目的は、低いコストで変更できるようにすること。

それを実現できる構造が必要。構造は大事。

アーキテクチャには堅牢性だけでなく、このような変更容易性も必要。

# ◆第Ⅱ部　構成要素から始めよ：プログラミングパラダイム

※メモ

* 依存性逆転により、コンポーネントそれぞれを独立してデプロイ・開発可能と書かれているが、実際には無理でしょ。サーバー単位で分けないとそれは無理。
* 可変コンポーネントは並行処理で問題になったりするので避けるべき。

# ◆第Ⅲ部　設計の原則

クラスレベル向けの原則：SOLID

目的は、クラスを以下の状態にすること。

* 変更に強くする
* 理解しやすくする
* 再利用できるようにする

## 単一責任の原則

クラスの利用者ごとにクラスを分けるべき。利用者ごとにそのクラスをどう使いたいかが異なるため。ある利用者向けの変更をすることで、別の利用者に影響を与えないようにしよう、ということ。別々の利用者向けの修正が同時にされることで、マージの手間も生まれてしまう。

## オープン・クローズドの原則

ビジネス上コアな処理を修正せずに、それ以外の瑣末なものを拡張できるようにすべき。（＝ 拡張に対しては開いていて、修正に対しては閉じているべき。）

これを実現するために、ビジネス上コアでない瑣末な処理を、常に「依存する」側に配置すべき。時には依存関係を逆転させる必要あり。

「今後、どんな変更があり得るのだろうか？」を考え、その変更の時に、よりコアなところを修正しなくても済むように、依存関係を調整するのがアーキテクトの腕の見せどころってことかな。

現実には、画面とコアなビジネスロジックはセットで変更になることが多いはずで、その場合にはこのように調整しても実際にはあまりメリットはない。つまり、画面だけを修正すればコアなビジネスロジックは変更不要、ということはあまり無い。コアなビジネスロジックが変わったら、それに依存する画面にも変更が入るのは当然のことであり、現実にはそういった類の要件変更が多い。

画面のテクノロジー（Thymeleafなど）を別のものに切り替えたり、画面以外のビューに対応する、といった大掛かりな変更も現実にはなかなか起こらない。ビューに柔軟性を持たせる、という戦略が必要となる局面は稀だと思われる。

つまり、この原則が功を奏するのは限定的だということ。

## リスコフの置換原則

この本質は、呼び出し先を他のパーツに変更しても、呼び出し元がコード上の影響を受けないようにすべき、ということ。呼び出し先のクラスがAの場合、呼び出し元が特別な処理（if文など）をするようだと、特別扱いが発生して変更が大変になってしまう。

## インターフェイス分離の原則

あるクラスが、本来関係のないものに依存していると、その関係ないのものが変更された時にクラスの再コンパイル・再デプロイが必要となる。それを避けるためにインタフェースを分離すべき、というもの。

だが、通常どこかを変更したら全量のコンパイル・デプロイが必要になるから、この原則も重要性は低い、というか考慮不要ではないかと思う。

## 依存関係逆転の原則

クラスはできるだけ抽象（インターフェイス）に依存すべき。なぜならインターフェースは変更しないよう設計されるのが普通であり、その変更されないものに対して依存しておけば、クラスも変更されづらくなるから。

つまり、この原則はインターフェイスが変更されづらいものとなるよう、注意深く設計されていることが大前提となる。インターフェイスに依存させるようにしたとしても、そのインターフェイスそのものがコロコロ変更されるようであれば、何の意味もない。

# ◆第Ⅳ部　コンポーネントの原則

どのクラスをどのコンポーネントに含めるか、ということについての原則。

## 再利用・リリース等価の原則　The Reuse/Release Equivalence Principle (REP)

特定のクラスやクラス群を再利用するのではなく、リリースされた「コンポーネント全体」を最小の単位として再利用しましょう、ということ。これを推し進めると、コンポーネントは大きくなる。

コンポーネントというのはある程度のまとまり（クラスの集まり）であり、リリース周りの管理がしっかりされているべきだ、という意味。

リリース周りの管理とは

* リリースに対してバージョン番号を振ること。
* リリースによってどんな影響があるかを、呼び出し元に公開すること。
* Maven Centralなどにコンポーネントを登録すること。

これを疎かにすると、利用する側はとっても困る。最悪、そのコンポーネントを再利用できなくなる。

なぜなら

* コンポーネントをvupしようとしても、自分たちにどんな影響があるのか分からない。
* 本来１つのコンポーネントにまとめるべきクラスが、複数のコンポーネント（JAR）に分かれている場合、それら両方を依存関係に含める必要あり。

この原則を推し進めると、リリース運用がすごく大変になる。いちいちバージョン番号を振ったり、変更による影響を公開する必要があるため。

## 閉鎖性共通の原則　The Common Closure Principle (CCP)

何らかの理由でコンポーネントを修正すべきとなったときに、修正すべきコンポーネントは１つだけの方が楽。なので、修正すべき理由が同じクラス群は、１つのコンポーネントにまとめるべき。修正範囲はコンポーネント内に限定される（閉じる）、という意味で「閉鎖性」という表現が使われている。

この原則を推し進めると、コンポーネントは大きくなる。

## 再利用共通の原則　The Common Reuse Principle (CRP)　

※「全再利用の原則」と訳されているが、これは不適切な訳。「The Common Reuse Principle」のどこにも「All」とは書いてない。

一緒に利用されることが多いクラス群、密結合なクラス群は１つのコンポーネントにまとめるべき。

逆に、密結合していないクラス群を１つのコンポーネントに含めるべきではないと言われている。これに反すると、利用する側にとってはどうでも良いクラスが変更された場合でも、利用する側の再コンパイル・再デプロイが必要になる、という理由。でも、別にどうでも良い変更なら利用する側では新しいコンポーネントを取り込まなければ良いだけなんだから、そこまで大きな話ではないと思われる。

ということで、この原則に従って、コンポーネントが大きくなっても、あんまり問題にならないと思ってる。

書籍では、各原則にはトレードオフの関係があると言っているが、上記のとおり全てコンポーネントが大きくなる方向で特段問題ないので、私としてはトレードオフなど無いと考えている。

上記原則を気にしながら、凝集性の高いコンポーネントにしていけば良いはず。

## 非循環依存関係の原則（ADP）

循環依存がダメなのは解説するまでもないと思う。

## 安定依存の原則（SDP）

依存する側からされる側へ、どんどん依存関係のグラフを辿っていくと、奥にあるコンポーネントほど変更しづらくなっていく。なぜなら、修正時の影響範囲が大きくなってしまうから。

その奥深いところに「変更しやすくしたいコンポーネント」を配置したいなら、間にインターフェース等の抽象層を挟んで依存関係を逆転させ、誰にも依存されないように（誰の顔色も伺わずに修正できるように）すべき。

## 安定度・抽象度等価の原則（SAP）

* 安定度の高いコンポーネント（他から依存されまくるもの）ほど、変更しやすさを確保するために抽象度を高くしよう（インターフェイス等をたくさん使おう）。安定度が高いということは、色々なところから依存されまくっており、変更するハードルがすごく高いということ。そうであっても変更しやすさを確保するために、抽象層を挟むべき。
* 逆に、安定度の低いコンポーネント（他に依存しまくるもの）ほど、抽象化するのは無駄なだけなので抽象度は低くすべき。

なお、安定度が高い＝良い、と言う話ではない。安定度に応じて、適切な抽象度を選ぶべきということ。


# ◆第Ⅴ部　アーキテクチャ

アーキテクチャの設計とは、変更の理由・頻度が同じものをまとめて、異なるものを分離すること。

![architecure-separation-orientation](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/architecure-separation-orientation.svg  "architecure-separation-orientation")

その目的は以下であり、究極的には「コストを下げること」である。

* 実装の詳細を変更・拡張しやすくする。
  * 例：ブラウザだけでなくモバイルアプリにも対応する。
* 並行開発（分業）をしやすくする。
  * 例：AチームとBチームで並行開発する。
* デプロイを手軽にする。
* 保守をしやすくする。どこを直すべきかが分かりやすい状態にする。

分離したコンポーネントを物理的にどう分割するか（切り離し方式）については、選択・変更できるようにしておく。切り離し方式（マイクロサービス化するなど）そのものは、アーキテクチャではない。

切り離し方式のバリエーション

![how-to-separate-components.svg](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/how-to-separate-components.svg "how-to-separate-components.svg")

最適な切り離し方式をギリギリまで吟味したり、運用しながら変更できることに価値がある。

コアなビジネスルールを持つコンポーネントに対して、そうでないコンポーネントが依存するようにすべき。後者はプラグインであり、前者に影響を与えることなく切り替えられるようにすべき。

例えばGUIは後者であり、プラグインであり、システムの本質ではない。コアなビジネスルールとは違い、状況によって移り変わるものなので、切り替えできるようにすべき。「IOは無関係」である。

前者は上位のコンポーネントであり、後者は下位のコンポーネント。入出力が最も下位であり、入出力から離れているほど上位となる。

最上位なのはビジネスルールであり、エンティティおよびユースケースである。

![business-rule.svg](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/business-rule.svg "business-rule.svg")

ビジネスルールは、実装の詳細・方式には依存しない。例えば、WebなどのIO形態やFWには依存しない。

システムはビジネスルールを中心とし、実装の詳細を中心とすべきではない。

これを表したのが、有名な同心円の図。多くのシステムはこのように水平方向での分割を適用できる、ということ。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/clean-architecure-circles.drawio.svg)


以下の図の本質は、制御の流れがどうであっても、依存の方向を適切に制御すべきということ。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/clean-architecture-flow-and-dependency.drawio.svg)






