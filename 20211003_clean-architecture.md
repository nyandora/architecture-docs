クリーンアーキテクチャ

# 用語

* コンポーネント：ソースコードのある程度のまとまり（典型的にはクラスの集まり）
* アーキテクチャ：コンポーネントにより構成されるシステムの構造のこと
  * この定義においては、いわゆるマイクロサービスアーキテクチャはアーキテクチャではない（後述）。

# ◆第Ⅰ部　イントロダクション

アーキテクチャ設計の目的は、低いコストで変更できるようにすること。

それを実現できる構造が必要。構造は大事。

アーキテクチャには堅牢性だけでなく、このような変更容易性も必要となる。

# ◆第Ⅱ部　構成要素から始めよ：プログラミングパラダイム

アーキテクチャ設計では、以下が求められる。

* コンポーネントをテスト可能（反証可能）な単位にすること。（構造化プログラミングに通ずる）
  * そうならないように作る方が逆に難しいくらいだけど・・。
* ポリモーフィズムを使って、コンポーネント間の依存関係の方向を、自在に制御できること。（オブジェクト指向プログラミングに通ずる）
* 状態を持つコンポーネントをできるだけ作らないこと。（関数型プログラミングに通ずる）
  * 並行性の問題を避けるため。

# ◆第Ⅲ部　設計の原則

クラスレベル向けの原則：SOLID

目的は、クラスを以下の状態にすること。

* 変更に強くする
* 理解しやすくする
* 再利用できるようにする

## 単一責任の原則

クラスの利用者ごとにクラスを分けるべき。利用者ごとにそのクラスをどう使いたいかが異なるため。ある利用者向けの変更をすることで、別の利用者に影響を与えないようにしよう、ということ。別々の利用者向けの修正が同時にされることで、マージの手間も生まれてしまう。

## オープン・クローズドの原則

ビジネス上コアな処理を修正せずに、それ以外の瑣末なものを拡張できるようにすべき。（＝ 拡張に対しては開いていて、修正に対しては閉じているべき。）

これを実現するために、ビジネス上コアでない瑣末な処理を、常に「依存する」側に配置すべき。時には依存関係を逆転させる必要あり。

「今後、どんな変更があり得るのだろうか？」を考え、その変更の時に、よりコアなところを修正しなくても済むように、依存関係を調整するのがアーキテクトの腕の見せどころってことかな。

現実には、画面とコアなビジネスロジックはセットで変更になることが多いはずで、その場合にはこのように調整しても実際にはあまりメリットはない。つまり、画面だけを修正すればコアなビジネスロジックは変更不要、ということはあまり無い。コアなビジネスロジックが変わったら、それに依存する画面にも変更が入るのは当然のことであり、現実にはそういった類の要件変更が多い。

画面のテクノロジー（Thymeleafなど）を別のものに切り替えたり、画面以外のビューに対応する、といった大掛かりな変更も現実にはなかなか起こらない。ビューに柔軟性を持たせる、という戦略が必要となる局面は稀だと思われる。

つまり、この原則が功を奏するのは限定的だということ。

## リスコフの置換原則

具象クラスは、抽象クラス/インターフェースが表す概念の一種になっているべき。

この本質は、呼び出し先を他のパーツに変更しても、呼び出し元がコード上の影響を受けないようにすべき、ということ。呼び出し先のクラスがAの場合、呼び出し元が特別な処理（if文など）をするようだと、特別扱いが発生して変更が大変になってしまう。

## インターフェイス分離の原則

あるクラスが、本来関係のないものに依存していると、その関係ないのものが変更された時にクラスの再コンパイル・再デプロイが必要となる。それを避けるためにインタフェースを分離すべき、というもの。

だが、通常どこかを変更したら全量のコンパイル・デプロイが必要になるから、この原則も重要性は低い、というか考慮不要ではないかと思う。

## 依存関係逆転の原則

具象クラスに依存するのではなく、逆に抽象に依存すべき。そうなるように依存関係を自由自在に制御すること。

目的は、依存先が変更されても、依存元が影響を受けないようにするため。

この原則はインターフェイスが変更されづらいものとなるよう、注意深く設計されていることが大前提となる。インターフェイスに依存させるようにしたとしても、そのインターフェイスそのものがコロコロ変更されるようであれば、意味はない。

# ◆第Ⅳ部　コンポーネントの原則

## コンポーネントの「凝集性」に関する原則
どのクラスをどのコンポーネントに含めるか、ということについての原則。

書籍では、各原則にはトレードオフの関係があると言っているが、後述のとおり全てコンポーネントが大きくなる方向で特段問題ない。なので、私としてはトレードオフなど無いと考えている。

各原則を気にしながら、凝集性の高いコンポーネントにしていけば良い。

### 再利用・リリース等価の原則　The Reuse/Release Equivalence Principle (REP)

特定のクラスやクラス群を再利用するのではなく、リリースされた「コンポーネント全体」を最小の単位として再利用しましょう、ということ。これを推し進めると、コンポーネントは大きくなる。

コンポーネントというのはある程度のまとまり（クラスの集まり）であり、リリース周りの管理がしっかりされているべきだ、という意味。

リリース周りの管理とは

* リリースに対してバージョン番号を振ること。
* リリースによってどんな影響があるかを、呼び出し元に公開すること。
* Maven Centralなどにコンポーネントを登録すること。

これを疎かにすると、利用する側はとっても困る。最悪、そのコンポーネントを再利用できなくなる。

なぜなら

* コンポーネントをvupしようとしても、自分たちにどんな影響があるのか分からない。
* 本来１つのコンポーネントにまとめるべきクラスが、複数のコンポーネント（JAR）に分かれている場合、それら両方を依存関係に含める必要あり。

この原則を推し進めると、リリース運用がすごく大変になる。いちいちバージョン番号を振ったり、変更による影響を公開する必要があるため。

### 閉鎖性共通の原則　The Common Closure Principle (CCP)

何らかの理由でコンポーネントを修正すべきとなったときに、修正すべきコンポーネントは１つだけの方が楽。なので、修正すべき理由が同じクラス群は、１つのコンポーネントにまとめるべき。修正範囲はコンポーネント内に限定される（閉じる）、という意味で「閉鎖性」という表現が使われている。

この原則を推し進めると、コンポーネントは大きくなる。

### 再利用共通の原則　The Common Reuse Principle (CRP)　

※「全再利用の原則」と訳されているが、これは不適切な訳。「The Common Reuse Principle」のどこにも「All」とは書いてない。

一緒に利用されることが多いクラス群、密結合なクラス群は１つのコンポーネントにまとめるべき。

逆に、密結合していないクラス群を１つのコンポーネントに含めるべきではないと言われている。これに反すると、利用する側にとってはどうでも良いクラスが変更された場合でも、利用する側の再コンパイル・再デプロイが必要になる、という理由。でも、別にどうでも良い変更なら利用する側では新しいコンポーネントを取り込まなければ良いだけなんだから、そこまで大きな話ではないと思われる。

ということで、この原則に従って、コンポーネントが大きくなっても、あんまり問題にならないと思ってる。

## コンポーネントの「結合」に関する原則

コンポーネント間の関係性について、いくつか原則がある。

### 非循環依存関係の原則（ADP）

循環依存がダメなのは解説するまでもないと思う。

### 安定依存の原則（SDP）

依存する側からされる側へ、どんどん依存関係のグラフを辿っていくと、奥にあるコンポーネントほど変更しづらくなっていく。なぜなら、修正時の影響範囲が大きくなってしまうから。

その奥深いところに「変更しやすくしたいコンポーネント」を配置したいなら、間にインターフェース等の抽象層を挟んで依存関係を逆転させ、誰にも依存されないように（誰の顔色も伺わずに修正できるように）すべき。

### 安定度・抽象度等価の原則（SAP）

* 安定度の高いコンポーネント（他から依存されまくるもの）ほど、変更しやすさを確保するために抽象度を高くしよう（インターフェイス等をたくさん使おう）。安定度が高いということは、色々なところから依存されまくっており、変更するハードルがすごく高いということ。そうであっても変更しやすさを確保するために、抽象層を挟むべき。
* 逆に、安定度の低いコンポーネント（他に依存しまくるもの）ほど、抽象化するのは無駄なだけなので抽象度は低くすべき。

なお、安定度が高い＝良い、と言う話ではない。安定度に応じて、適切な抽象度を選ぶべきということ。


# ◆第Ⅴ部　アーキテクチャ

## アーキテクチャ設計とは何か（what）
アーキテクチャ設計とは、変更の理由・頻度が異なるものを相互に分離し、それらの間の構造を定義すること。

![architecure-separation-orientation](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/architecure-separation-orientation.svg  "architecure-separation-orientation")

先に挙げた各種の原則にのっとって、設計をしていくことになる。

## アーキテクチャ設計の目的とは（why）

アーキテクチャ設計の目的は以下。

* 実装の詳細を変更・拡張しやすくする。
  * 例：ブラウザだけでなくモバイルアプリにも対応する。
* 並行開発（分業）をしやすくする。
  * 例：AチームとBチームで並行開発する。
* デプロイを手軽にする。
* 保守をしやすくする。どこを直すべきかが分かりやすい状態にする。

その先にある究極的な目的は「コストを下げること」である。

## アーキテクチャ設計の再重要ポイント

コアなビジネスルールを持つコンポーネントに対して、そうでないコンポーネントが依存するようにすべき。後者はプラグインであり、前者に影響を与えることなく切り替えられるようにすべき。

例えばGUIは後者であり、プラグインであり、システムの本質ではない。コアなビジネスルールとは違い、状況によって移り変わるものなので、切り替えできるようにすべき。「IOは無関係」である。

前者は上位のコンポーネントであり、後者は下位のコンポーネント。入出力が最も下位であり、入出力から離れているほど上位となる。

最上位なのはビジネスルールであり、エンティティおよびユースケースである。

![business-rule.svg](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/business-rule.svg "business-rule.svg")

ビジネスルールは、実装の詳細・方式には依存しない。例えば、WebなどのIO形態やFWには依存しない。

システムはビジネスルールを中心とし、実装の詳細を中心とすべきではない。

以上を表したのが、以下の有名な同心円の図（私なりに噛み砕いた表現にしている）。多くのシステムはこのように水平方向での分割を適用できる、ということ。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/clean-architecure-circles.drawio.svg)

以下の図の本質は、制御の流れがどうであっても、依存の方向を適切に制御すべきということ。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/clean-architecture-flow-and-dependency.drawio.svg)


##　アーキテクチャ設計におけるトピック

### 切り離し方式のバリエーション

分離したコンポーネントを物理的にどう分割するか（切り離し方式）については、選択・変更できるようにしておく。切り離し方式（マイクロサービス化するなど）そのものは、アーキテクチャではない。

![how-to-separate-components.svg](https://raw.githubusercontent.com/nyandora/universal-static-resources/main/box/how-to-separate-components.svg "how-to-separate-components.svg")

最適な切り離し方式をギリギリまで吟味したり、運用しながら変更できることに価値がある。

### テストしづらいコンポーネントの扱い方

![](https://github.com/nyandora/universal-static-resources/raw/main/box/humble-object.drawio.svg)

ということは、Humbleなクラスに自動テストを設けるのは、ナンセンスということ。

### コンポーネントの境界をどれだけしっかり作るか

コンポーネント間の境界をどれだけしっかり作るか、には程度（選択肢）がある。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/component-separation-levels.drawio.svg)

状況に応じて、適切なものを選ぶことが大事。
例えば、本当にその境界が必要なのかが判断できない時は、ゆるいやつを選んでおくのが良い。

### 未来を予想して、境界を予め設ける

境界を設けるのはけっこう難しい。

境界をつくるということは少なからず手間が発生する。
なので、はじめから無闇に境界を設けるべきではない。

一方で、全く境界がないところに、一から境界を設け直すのは不可能に近い。
既存のものに影響を与えずに境界を設けるのは「大手術」であり、リスクとコストが大き過ぎる。

なので、未来を予想して、境界を絶妙に設けておく必要がある。
ここがアーキテクトの腕の見せどころ。

なお、書籍にあるマイクロサービスの例は、「境界を設けるべきか悩ましいケースがあり、未来予想によっては境界が必要と判断するケースがあるよ」ということを示しているだけ。必ずこうしましょう、という話ではない。

### 実装の詳細に過ぎないものたち

#### サービス

サービスは単なる高価な関数呼び出しに過ぎない。

言い換えると、実装の詳細、つまり実行の物理的な仕組みや通信の方式に過ぎず、アーキテクチャを決定づけるものではない。

アーキテクチャの境界は、サービスの分割とは別次元で（直行して）存在し得る。

![](https://github.com/nyandora/universal-static-resources/raw/main/box/architecutre-boundary-cross-over-service.drawio.svg)

#### Web、DB、FW

これらも実装の詳細に過ぎない。状況によって変更すべきもの。

### 抽象に対してテストすべき

テストも抽象に依存させるのが正しい。つまり、実装の詳細という変化しやすいものに依存してはいけない。

プロダクションコードの個々のクラスやメソッドに対して、細かく自動テストを設けていたら、変更時にとんでもない負担になるだけ。

ユースケースやエンティティといった、上位レベルの抽象的なものに対してテストをすべき。その際、DBアクセスやAPIコールなどの動作を再現しづらいものは、モック化しておけば良い。

### 境界は強制されるべき

プログラマに境界のルールを強制させないと、せっかくのアーキテクチャ設計が台無しになってしまう。

Java 9で導入されたモジュールなどを利用して、コンパイラにチェックさせるようにするのが好ましい。

### Mainコンポーネントは実装の詳細で切り替え可能

円の最も外側に、アプリケーションのエントリーポイントがいる。

これはMainコンポーネントと呼ばれる。
Mainコンポーネントは究極的な実装の詳細であり、プラグイン（切り替えられるもの）である。

具体的には以下を行う。

* 依存関係の注入
* 設定値の読み込み
* 上位レベルのコンポーネントに制御を移す

Spring Bootでいえば、`@SpringBootApplication`をつけたクラスが該当する。
