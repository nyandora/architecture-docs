# 分散システムとマイクロサービス


# 方式
## トランザクション

１リクエストの中で、複数のマイクロサービスに対して更新を行うことがあります。

この場合、ACID特性のうち原子性、一貫性、分離性を満たすことが難しいです。

* 原子性については、失敗したときに完全にロールバックするのが難しいです。
* 一貫性については、原子性と関連しますが、失敗した時に完全にロールバックできないことにより、複数のマイクロサービス間のデータが整合しない状態が起こります。
* 分離性については、一連の更新がまだ終わっていない or ロールバックが終わっていないのに、途中の更新結果が一連の処理の外部から観測できてしまいます。

これらを（ほぼ）完璧に解消できる方式はあるのですが、いきなりそれに飛びつくべきではありません。新規構築、保守に多大なコストがかかるからです。

まずやるべきことは「調整」です。

* 上記の難点によってどんな実害がでるかを、リクエストごとに明確化する。
* その実害は業務上、許容範囲であるか評価する。

多くのケースでは、先述の実害が許容されるはずです。

例えば、以下のような結論となるでしょう。

* 確かに不整合は起こるが、エンドユーザーに再試行してもらえば済む。エンドユーザーはきっとこれくらいでは怒らない。
* エンドユーザーが登録した結果が一覧画面に表示されないようになり、エンドユーザーは「あれ？さっき登録したのにおかしいな」と思うかもしれない。ただ、注文のような重要業務ではないので、深刻な状態にはならない。
* 失敗した事実をログで残せば、失敗したものをピックアップして、手動で更新SQLを実行すれば良い。数日以内にやれば、エンドユーザーは怒らないし、大した運用コストにはならない。

上記の調整をしても、どうしても実害を許容できない場合は、以下の選択肢を採用できます。

* 取消APIを呼び出して、対向先で行われた更新を取り消す。
* Sagaを導入する。
  * https://docs.microsoft.com/ja-jp/azure/architecture/reference-architectures/saga/saga

取消API方式には、以下の難点があります。

* 取消APIの呼出が成功するとは限らない。
  * 取消APIが失敗することはあり得る。
  * 取消APIの呼び出しがタイムアウトとなった場合、呼び出し元は取消の成否を判断できない。
* 取消が完了していないのに、別のリクエストが到来し更新が実行され、事態が悪化する恐れがある。
* 更新対象のAPIが3つ以上の場合、上記への対処は複雑さを極める。



