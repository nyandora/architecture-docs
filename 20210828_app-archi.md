大規模開発における「真に優れた」アプリケーションアーキテクチャとは？

大規模開発をしているとアプリケーションアーキテクチャ、責務配置をどうするかを考えることになります。

色々な手法がありますが、誤って導入してしまい残念なことになります。例えば、PMやPOといったいわゆるエライ人から、作業の必要性について納得を得られません。「それ、やらなかったらどうなるの？」の問いに対して、エライ人が納得する答えを返せないわけです。そうなるとPJは円滑に進まなくなります。

現場で開発するシステムは芸術作品ではありません。何らかの形で利益を生み出さないと意味がありませんから、実益を重視した判断していく必要があります。そういった観点で、アプリケーションのアーキテクチャというものを考えてみたいと思います。

# アプリケーションのアーキテクチャを練るべき理由

アプリケーションのアーキテクチャを練るべき理由は、このアーキテクチャが以下に直結するためです。

* 新規開発のしやすさ
  * メンバーが迷わずに開発できる。
  * メンバーのスキルが低くても、「変な実装」になりづらい。
  * テストしやすい。
  * ビルドにかかる時間が短い。

* 保守開発時の修正しやすさ
  * 現状を理解しやすい。
  * 修正すべき箇所を特定しやすい。
  * 修正によって影響を受ける範囲が狭い。

これらを達成するのが重要なわけですね。最近よく取り上げられる手法について、こういった観点で評価していきたいと思います。

# モダンな手法に対する評価
## Clean Architectureってどうなの？

Clean Architectureはビジネスロジックが瑣末なものに依存しないようにして、修正しやすくするアーキテクチャです。なお、Clean Architectureの文脈では、web/application/domain/infraといった層の話がよく出てきますが、これらの層で分けなさい、というわけではありません。

例えば、外部システムのREST APIを叩いてデータを取得し、そのデータを使って計算処理を行うとします。

「外部システムのREST APIを叩いてデータ取得」の部分が瑣末なもので
「計算処理」がビジネスロジック（つまり大事なもの）に当たります。

このAPI仕様が変わることは、それなりにあり得ます。
必須パラメータが追加される、とかです。

ただ、こちら側にとってはどうでも良い、つまり毎回同じ値を設定しておけば良いということがあります。例えば何らかのフラグが追加されたとして、ビジネスロジック側は常にtrueでOKという場合です。

そのような場合、ビジネスロジック側にも本来どうでも良いのに修正が入ってしまいます。そのAPIを呼び出しているビジネスロジックが多い場合、その分無駄な修正が発生します。

そういったことを避けられる、というのが良いところです。

ただ、そのAPIの呼び出し元については結局リグレッションテストをやるべきで、そういった面の手間は全く変わりません。なので、ちょい嬉しい、くらいのメリットしかないです。

また、API仕様が変わるとして後方互換性のある変更がほとんどでしょう。そのような場合は呼び出し元をわざわざ変更することはありません。後方互換性のない変更に従わざるを得ない場合にのみ、上記のようなメリットが生まれます。そのような機会は滅多にないので、そういった意味でもメリットは小さいと言えましょう。

なので、実益というよりも芸術的な意味合いでのメリット、つまり自己満足の領域なのではないかなと思います。

つまり、Clean Architecureは、大したメリットなしと評価できます。

## DDDってどうなの？

DDD（ドメイン駆動設計）は、ビジネス上の表現をそのままコードに落とし込み、修正しやすくする設計手法です。

大規模開発ではこれを選択するのはやめておいた方が良いです。なぜなら「ユビキタス言語の整備」「オブジェクトのモデリング」をしっかりやらないと真価を発揮できないためです。
大規模開発では、そういったことを設計している暇ありません。手続き的に処理を設計するだけで精一杯となります。

「ユビキタス言語の整備」「オブジェクトのモデリング」をやらずに、エンティティ/値オブジェクト/リポジトリ/集約などを導入しようとしてもうまくいきません。

開発メンバーは「何をどう分割したら良いの・・？」と困ってしまうからです。

そのまま強引に進めてしまうと、単なるDTOにすぎないエンティティができたり、結局ドメインサービスに全ての処理が手続き的に実装されてしまうだけとなります。

# ではどうすべきなのか？

## 画面アプリケーションにおける「ビジネスロジック」とは？

画面アプリケーションの場合、内部のビジネスロジックだけで機能を実現しているわけではありません。そもそも「〇〇の時に画面に〇〇と表示する」といったことが機能なのですから、画面表示も一体なわけです。

その場合、リクエストからパラメータを受け取り、バリデーションを行い、画面表示に必要なデータをかき集め、ビューを使ってHTMLを作るといった動きになります。

この場合、ビジネスロジックとは何を指すのでしょうか？

金額計算など、複雑な計算処理があればそれがビジネスロジックと言えるでしょうが、そういった典型的なロジックが出てくるのは稀だと思います。

この点で、一連の処理がまるごとビジネスロジックと言えるでしょう。この場合、依存関係の末端となるべき（依存されるだけの）存在というのはいない、ということになります。であれば、Clean Architectureの考えは、あまり役に立たないということになるでしょう。

# では何が大事なのか？

意味のある、独立したまとまりでコードが分割されていること。
例えば、必要なデータを集めてくる処理は、画面内のエリアごとに分割され、クラスが分けられていること。
ビュー（Thymeleafなど）に表示データを連携する処理も同様です。Presenterを作る。

ロジックが散在していると読み解く時に大変なので、表示についてのロジックはビュー（Thymeleafなど）に直接書かない
Presenterに実装して、Controller側のコードを見ればロジックが分かる、という状態にしておく。

# プロトコル依存の要素をWeb層で断ち切る件

例えば、Cookieを扱う処理はWeb層で行う、みたいな話ですね。
CookieはHttpServeletRequestに入ってて、後続の処理がそういったものに依存するとテストがしづらくなるので、Web層でそういった要素を断ち切りましょう、ということです。

ですが、現場では何から何まで自動テストをつくるわけではありません。自動テストをつくるのは、粒度の小さいものだけでしょう。

それが目的なのであれば、自動テストをつくるような粒度の小さい部品に、プロトコル依存の型を渡さないようにすれば良いだけです。



# DTOは？


