coroutineとは、軽量なスレッド。Kotlin固有の概念ではない。
https://kotlinlang.org/docs/reference/coroutines/basics.html

coroutineの最大の特徴は、中断（suspend）できること。一方、通常のスレッドは中断することはできず、ブロックすることしかできない。

「中断」とは、別の処理で利用できるようにcoroutine（つまりスレッド）を解放すること。`async await`の動作イメージに近い。「実行する権利」を別の処理に一時的に渡している感じ。

「ブロック」とは、スレッドの実行を一時停止すること。停止している間は「実行する権利」が別の処理に渡されることは無い。単純に何もしない時間が生まれるだけ。停止している間にもスレッドにCPUやメモリが消費されるため、その分だけCPUやメモリを無駄遣いしていることになる。

スレッドでも並列処理はできるんだけど、何らかの待ちが発生した場合、その間もサーバーのリソースがスレッドに割かれたままになる。coroutineでは、待ちが発生したら中断することができ、別のcoroutineにサーバーのリソースを割り当て、その別のcoroutineを実行できる。

これが最大の特徴。

つまり、coroutineによって処理を実行する、ということは「待ち」が必要な処理であっても、待っている間に他の処理にCPUやメモリを渡すことができる（メモリを渡すってどういうこと？）ということ。サーバーのリソースを無駄遣いしないということ。

電子レンジで飲み物を１分温めている間、ずっと電子レンジの前で待っているのが「ブロック」。一方、その１分間を無駄にせず、読みたい本を本棚から取ってくるのが「中断」。



Coroutineにはスコープという概念がある。coroutineが属する仮想的な領域のこと。あるスコープ内で起動されるcoroutineはデフォルトでは親coroutineの管理下に入るが、明示的にグローバルスコープで定義したものは、親の管理下に入らない。スコープには一連のコルーチンが属する。coroutineを起動すると自動的にローカルなCoroutineScopeが設けられ、親coroutineがまずそこに属する。その親coroutineから起動された子coroutineも同じスコープに属するのであり、それらの子coroutineが終了するまで、親coroutineの次にある処理は実行されない。それらのcoroutineが終了するまで親のcoroutineは中断され、サーバーリソースは他の処理に回される。

複数のCoroutineを起動させて実現したい処理があり、一連の処理が終わってから次の処理をしたい、という場合、前者をまとめて`await`するようなイメージ。

全てのcoroutine builderは、CoroutineScopeを自動的に生成し、そのスコープの中で親coroutineを実行してくれる。coroutine builderが作る親coroutineはローカルなスコープの中で実行され、その中で起動した子Coroutineの実行が完了してはじめて、親coroutineも完了できる。そのスコープの中で実行される子coroutineについては、完了するまで状況を監視するといったことを、暗黙的にやってくれるってことなんだな。他にも、スコープ内で例外がスローされた場合、自動的にそのスコープ内のCoroutineはキャンセルされる。

つまり、まずは親coroutineが特定のスコープの中で起動され、その中で子Coroutineを作って並列処理をするってことだな。

CoroutineScopeの中でもGlobalScopeというものがあり、その名の通り、アプリケーション全体に係るスコープ。ここで実行されたcoroutineは、自動的に監視されない。つまり、起動したCoroutineの参照を保持し、それらの終了を待つという処理（`join`）を、自前で明示的に書く必要がある。`await`的なことを実現するのに、手間がかかるってことかな。

また、GlobalScopeの中で実行されたcoroutineがハングした場合、そのcorroutineへの参照を保持して監視しない限り、ハングしたということを検知できない（ということだと思う）。coroutineを起動しすぎてメモリが不足した場合にも、同様の理由でハンドリングできない（ということだと思う）。

通常のスレッドにはスコープという概念はなく、常にグローバルで実行されているようなもので、上記のようなリスクをはらんでいる（多分）。

最後の例では、親coroutineの実行が終わった瞬間にメインスレッドも終わるので、グローバルスコープのcoroutineも強制終了されるってことだな。


特定のスコープでcoroutineが実行される場合は、ハングしても何かしら良い感じにハンドリングされるのだろうか？これについては要確認だな。
→　外側からキャンセルできたり、withTimeoutでタイムアウトさせることができる。



`suspend`が付いた関数では、「coroutineを中断する処理」が実行される。coroutineのみが実行できる。


Coroutineでの`async`は、処理を別coroutineで起動し、Deffered(Promise的なもの)を返す役割をする。返されたDefferdを`await()`することで、結果が返ってくるまで待つことができる。



Coroutine Contextとは、様々な要素(job, dispatcherなど)の集合。

Dispatcherは、対応するcoroutineをどのスレッド/スレッド群が実行するのかを決定する。　coroutineはスレッドによって実行されるものってことか。

Coroutineを起動するときに、そのCoroutineにどのDispatherを割り当てるかを明示的に指定できる。で、そのDispatcherがそのCoroutineをどのスレッドで実行するかを決定する。つまり、あるCoroutineをどのスレッドで実行するかを制御するために、そのDispatcherを割り当てるのかを決める。

CoroutineScopeの中にContextがある感じ。何も指定せず`launch`すると、親coroutineのCoroutineScopeにあるContext（Dispatcher含む）を、子croutineが引き継ぐ。結果、親coroutineがmainスレッドで実行さっれていれば、子coroutineもmainスレッドで実行される。

coroutine起動時に`Dispatchers.Unconfined`（を含むContextを）使うように指定すると、起動時は親coroutineを起動したスレッドで起動するが、いったん中断した場合、再開するときは別のスレッドを割り当てる可能性がある。

Scope/Context/Dispatcher/Thread/Coroutineの関係性。

```
CoroutineScope
  CroutineContext
    Dispatcher : determines what Thread executes a Coroutine.
    Job
    CoroutineExceptionHandler
```

https://codelabs.developers.google.com/codelabs/kotlin-coroutines?hl=ja#3

When a coroutine calls a function marked suspend, instead of blocking until that function returns like a normal function call, it suspends execution until the result is ready then it resumes where it left off with the result. While it's suspended waiting for a result, it unblocks the thread that it's running on so other functions or coroutines can run.

コルーチンがsuspend関数を呼び出すと、コルーチンは中断する。suspend関数が完了したら、その結果を使って、コルーチンは中断したところから再開する。コルーチンが中断している間、そのコルーチンを実行するスレッドはブロックされない。そのスレッドは別の処理を行うことができる。

メインスレッドとは別のスレッドがsuspend関数を実行するとは限らない。メインスレッドで実行することもできるし、別のスレッドで実行することもできる。

ネットワーク処理での応答待ちの間にメインスレッドをブロックしたくない、という場合はどうするのか？親コルーチンが子コルーチンを起動する。子コルーチンがメインスレッド以外のスレッドで実行されるように、子コルーチン起動時のContext(Dispatcher)を設定する。その子コルーチンの中で、ネットワーク処理を実行する。

子コルーチンを起動する関数はsuspendなので、親コルーチンは中断する。子コルーチンが起動され、（メインスレッドではない）別スレッドにDispatchされる。別スレッドでは応答待ちの間も拘束されるが、メインスレッドは別の処理を行うことができる。子コルーチンの処理が完了すると、子コルーチンを起動する関数も完了するので、親コルーチンはその関数の処理結果を使って自身の処理を再開する。

とすると、この用途で子コルーチンを多数起動した場合、結局ふん詰まってしまう気がする。マルチスレッドで起動する場合とあんまり変わらないのではないか？
以下によると、実際その通りのようだ。
https://qiita.com/t-otsuka/items/41b665a698655a5c033b

コルーチン内で実行するネットワーク処理が、待ち時間の間に良い感じにsuspendするものでないとこうなってしまうってことだな。

じゃあ、コルーチンの使いどころって何なのか？いくら軽量といっても、結局メインスレッドで実行されるならシーケンシャルに実行してるのと大して変わらない気がする。

非同期実行して指定したコールバックを実行する、という処理を、同期的っぽく書けるというのはメリット。非同期処理側にいったんスレッドを渡して、終わったら呼び出し側にスレッドを戻して、呼び出し側で非同期処理側の処理結果を受け取れる。ってことかもしれんな。Androidとかでは非同期のAPIというのがあって、コールバックを渡す必要があったので、この点が有難いんだろうな。

スレッドをブロックせずに並列処理（cuncurrentであり同時実行という意味ではない）をできる。中断できるタイミングですぐにスレッドを解放してくれるから、サーバー負荷を抑えられる。がっつりとした計算処理がある場合は、並列で動かしたとしても同じスレッドでやってたら意味はないが、ネットワークの処理応答待ちなどの中断できる動きが、その処理の大半を占めるのであれば、かなり効果的。というかそう時にこそ使うものだな。

処理をどのスレッドでどう動かすか、ということをきめ細かく制御できる、というのがコルーチンの本質なのかもしれないな。

grpc-kotlin-stub.jarにあるServerCalls.ktのserverCallListener()では、
サーバーにリクエストが到達するたびに、Serviceインスタンスごとに用意されたEmptyCoroutineContextを使って、リクエストごとにCoroutineScopeが定義され、その中でコルーチンが起動する。そのコルーチンの中で、自分たちの定義したメソッドが呼ばれる。

リクエストごとにコルーチンが起動される目的は、個々の実装者がコルーチンを使えるようにするためだろう（ここの実装者がスレッドをきめ細かく制御できるようにすることだろう）。


協調的、というのは自身で制御をOSに戻す性質のこと。反対にプリエンティブというのは「横取り」を意味し、OS側が処理から制御を強制的に奪う性質。
https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%AB%E3%83%81%E3%82%BF%E3%82%B9%E3%82%AF

コルーチンは協調的なので、外部からキャンセルが要求された場合に、自身の制御をOS側に戻すことができる。



launchで起動されたコルーチンで例外が発生し、最後（ルートのコルーチン）まで伝播させると、コルーチン終了後に、
キャッチされなかった例外としてその例外がCoroutineContextにあるCoroutineExceptionHandlerに渡され、ログ出力などに利用できる。
一方、asyncで起動したコルーチンでは、発生した例外はDefferedに詰め込むものとして必ずcatchされるので、
キャッチされなかった例外というのは発生しない。なのでCoroutineExceptionHandlerは呼ばれることはない。

コルーチンがキャンセルされると、コルーチン内部でCancellationExceptionがスローされ、（finallyとかの後で）コルーチンは終了する。
しかし、この例外だけは、そのコルーチンの親コルーチンに伝播しても、親コルーチンはキャンセルされない。

CancellationException以外の例外がコルーチンでスローされると、それは親のコルーチンに伝播して親コルーチンをキャンセルさせる。
すると、芋づる式に他の子コルーチンもキャンセルしていく。
全てのコルーチンがキャンセルされ処理が完了したのちに、ルートのコルーチンのCoroutineExceptionHandlerが実行される。








